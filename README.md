# 🚀 Golang 100가지 실수패턴과 솔루션

> Go 언어 개발 시 자주 발생하는 실수들과 그 해결 방법을 정리한 가이드입니다. 각 패턴은 실제 코드 예제와 함께 설명되어 있습니다.

## 📑 목차

1. [기본 문법과 구조](#1-기본-문법과-구조)
   - 변수 스코프, 코드 구조, 초기화, 인터페이스, 제네릭, 함수형 프로그래밍
2. [슬라이스와 메모리 관리](#2-슬라이스와-메모리-관리)
   - 슬라이스 기초, nil/빈 슬라이스, 메모리 관리
3. [프로젝트 구조와 도구](#3-프로젝트-구조와-도구)
   - 표준 프로젝트 구조, 코드 품질 도구
4. [기타 중요 개념](#4-기타-중요-개념)
   - 값 비교, 반복문 처리, 문자열 처리

## 1. 기본 문법과 구조

Go 언어의 기본적인 문법과 구조적 패턴에 대한 가이드입니다.

### 1.1 변수와 스코프 🔍
- [의도하지 않은 변수 가림을 조심하라](./1.go)
  > 변수 스코프와 가림(shadowing) 문제를 다루는 예제입니다. 블록 내에서 외부 변수를 가리는 실수를 방지하는 방법을 보여줍니다.
  ```go
  // ❌ 잘못된 예
  x := 1
  {
      x := 2  // 외부 x를 가림
  }

  // ✅ 올바른 예
  x := 1
  {
      y := 2  // 새로운 변수 사용
  }
  ```

### 1.2 코드 구조 🏗️
- [중첩된 if 문을 피하라](./2.go)
  > 복잡한 조건문을 단순화하고 가독성을 높이는 방법을 보여주는 예제입니다. 중첩된 if문을 피하고 더 명확한 코드 구조를 만드는 방법을 설명합니다.

### 1.3 초기화와 전역 상태 ⚠️
- [init 함수를 피하라](./3.go)
  > init 함수의 사용을 피하고, 대신 전역변수와 구조체를 활용한 명시적인 초기화 방법을 보여주는 예제입니다. 초기화 로직의 명확한 관리 방법을 설명합니다.

### 1.4 인터페이스 설계 🎯
- [인터페이스 설계 원칙](./4.interface/)
  > 인터페이스 설계의 핵심 원칙을 보여주는 예제들입니다:
  - [제공자 측이 아닌 사용자 측에 인터페이스를 두어라](./4.interface)
    > 인터페이스는 구현체가 아닌 사용자 측에서 정의해야 함을 보여주는 예제입니다.
  - [any 타입의 과도한 사용을 피하라](./4.interface)
    > any 타입 사용의 위험성과 더 구체적인 타입 사용의 이점을 보여주는 예제입니다.

### 1.5 제네릭 🧩
- [제네릭이 필요한 시점을 파악하라](./5.go)
  > 제네릭의 적절한 사용 시점과 주의사항을 보여주는 예제입니다. 타입 안전성과 코드 재사용의 균형을 설명합니다.

### 1.6 함수형 프로그래밍 🔄
- [함수형 패턴을 활용하라](./11.함수현_패턴/)
  > Go에서 함수형 프로그래밍 패턴을 효과적으로 활용하는 방법을 보여주는 예제들입니다. 고차 함수와 불변성을 활용한 코드 작성 방법을 설명합니다.

## 2. 슬라이스와 메모리 관리

Go의 슬라이스와 메모리 관리에 대한 핵심 개념과 주의사항입니다.

### 2.1 슬라이스 기초 📏
- [슬라이스의 길이와 용량을 정확하게 이해하라](./15.go)
  > 슬라이스의 기본 개념과 동작 방식을 보여주는 예제입니다. 길이(len)와 용량(cap)의 차이, 그리고 슬라이스 확장 시의 동작을 설명합니다.
  ```go
  // 기본 개념
  s := make([]int, 3, 6)  // len: 3, cap: 6

  // ❌ 잘못된 사용
  s[3] = 10  // 범위 초과 에러

  // ✅ 올바른 사용
  s = append(s, 10)  // 안전한 추가
  ```
  > 💡 **팁**: 용량이 1024 이상일 때는 25%씩 증가합니다.

### 2.2 nil과 빈 슬라이스 ⚖️
- [nil과 빈 슬라이스를 혼동하지 마라](./16.go)
  > nil 슬라이스와 빈 슬라이스의 차이점을 보여주는 예제입니다. 각각의 특징과 사용 시 주의사항을 설명합니다.
  ```go
  // nil 슬라이스 (초기화되지 않음)
  var s1 []string
  s2 := []string(nil)

  // 빈 슬라이스 (초기화됨)
  s3 := []string{}
  s4 := make([]string, 0)
  ```

### 2.3 슬라이스 검사 🔍
- [슬라이스가 비었는지 제대로 확인하라](./17.go)
  > 슬라이스의 상태를 올바르게 검사하는 방법을 보여주는 예제입니다. nil 검사와 길이 검사의 차이점을 설명합니다.
  ```go
  // ❌ 잘못된 검사
  if s == nil { ... }

  // ✅ 올바른 검사
  if len(s) == 0 { ... }
  ```

### 2.4 슬라이스 복제 📋
- [부정확한 슬라이스 복제 관련 실수](./18.go)
  > 슬라이스 복제 시 발생할 수 있는 실수와 올바른 복제 방법을 보여주는 예제입니다. 메모리 공유와 독립적인 복사의 차이를 설명합니다.
  ```go
  // ❌ 잘못된 복제
  b := a[:5]  // 메모리 공유

  // ✅ 올바른 복제
  b := make([]int, 5)
  copy(b, a)  // 독립적인 복사
  ```

### 2.5 메모리 관리 💾
- [슬라이스와 메모리 누수 관련 실수](./19.go)
  > 슬라이스 사용 시 발생할 수 있는 메모리 누수 문제와 해결 방법을 보여주는 예제입니다. 효율적인 메모리 관리 방법을 설명합니다.
  ```go
  // ❌ 메모리 누수
  a := make([]int, 1e8)
  b := a[:5]  // a의 메모리 참조 유지

  // ✅ 메모리 효율
  a := make([]int, 1e8)
  b := make([]int, 5)
  copy(b, a)  // 필요한 만큼만 복사
  ```

## 3. 프로젝트 구조와 도구

Go 프로젝트의 표준 구조와 개발 도구에 대한 가이드입니다.

### 3.1 표준 프로젝트 구조 📁
> Go 프로젝트의 표준적인 디렉토리 구조를 보여주는 예제입니다. 각 디렉토리의 역할과 사용 방법을 설명합니다.
```
📁 프로젝트 루트
├── 📁 cmd          # 실행 파일
├── 📁 internal     # 비공개 코드
├── 📁 pkg          # 공개 코드
├── 📁 test         # 통합 테스트
├── 📁 configs      # 설정 파일
├── 📁 docs         # 문서
├── 📁 examples     # 예제 코드
├── 📁 api          # API 정의
├── 📁 web          # 정적 파일
├── 📁 build        # CI/CD 설정
├── 📁 scripts      # 유틸리티
└── 📁 vendor       # 의존성
```

### 3.2 코드 품질 도구 🛠️
- [golangci-lint](https://golangci-lint.run/welcome/install/#local-installation) 활용
  > Go 코드의 품질을 검사하고 개선하는 도구 사용 방법을 보여주는 예제입니다.
  ```bash
  # 설치
  brew install golangci-lint

  # 실행
  golangci-lint run
  ```

## 4. 기타 중요 개념

Go 언어의 기타 중요한 개념과 패턴에 대한 설명입니다.

### 4.1 값 비교 ⚖️
- [값을 올바르게 비교하는 방법](./20.go)
  > 구조체와 복잡한 타입의 값을 올바르게 비교하는 방법을 보여주는 예제입니다. reflect.DeepEqual의 사용과 주의사항을 설명합니다.
  ```go
  // ❌ 구조체 직접 비교
  type Customer struct { id string }
  c1, c2 := Customer{"x"}, Customer{"y"}
  fmt.Println(c1 == c2)  // 컴파일 에러 가능

  // ✅ reflect.DeepEqual 사용
  fmt.Println(reflect.DeepEqual(c1, c2))
  ```

### 4.2 반복문 처리 🔄
- [range 루프 주의사항](./21.go)
  > range 루프에서 값 복사본 사용 시 주의해야 할 점을 보여주는 예제입니다. 원본 데이터 수정이 필요한 경우의 올바른 방법을 설명합니다.
  ```go
  // ❌ 값 복사본 사용
  for _, v := range items {
      v.Modify()  // 원본 변경 안됨
  }

  // ✅ 인덱스 사용
  for i := range items {
      items[i].Modify()  // 원본 변경
  }
  ```

- [맵 반복문에서의 동시 수정 주의사항](./23.go)
  > 맵을 반복하면서 동시에 수정할 때 발생할 수 있는 예측 불가능한 동작을 보여주는 예제입니다. 맵 복사본을 사용하여 안전하게 수정하는 방법을 설명합니다.
  ```go
  // ❌ 예측 불가능한 동작
  for k, v := range m {
      if v {
          m[10+k] = true  // 반복 중 맵 수정
      }
  }

  // ✅ 복사본 사용
  dm := copyMap(m)
  for k, v := range m {
      if v {
          dm[10+k] = true  // 복사본 수정
      }
  }
  ```

- [반복문에서의 break 레이블 사용](./24.go)
  > 중첩된 반복문이나 switch/select 문에서 break를 사용할 때의 주의사항과 레이블을 활용한 올바른 방법을 보여주는 예제입니다.
  ```go
  // ❌ 잘못된 break 사용
  for i := 0; i < 10; i++ {
      switch i {
      case 2:
          break  // switch만 빠져나감
      }
  }

  // ✅ 레이블 사용
  loop:
  for i := 0; i < 10; i++ {
      switch i {
      case 2:
          break loop  // 전체 반복문 종료
      }
  }
  ```

### 4.3 문자열 처리 📝
- [문자열 트림 함수의 차이점](./25.go)
  > Go의 문자열 트림 함수들의 동작 차이를 보여주는 예제입니다. TrimLeft, TrimRight, TrimSuffix, Trim의 각각의 특징을 설명합니다.
  ```go
  s := "oxo123123oxo"

  // 각 함수의 동작
  strings.TrimLeft(s, "ox")   // "123123oxo"  -> 왼쪽의 o, x 모두 제거
  strings.TrimRight(s, "ox")  // "oxo123123"  -> 오른쪽의 o, x 모두 제거
  strings.TrimSuffix(s, "ox") // "oxo123123"  -> 접미사 "ox" 제거
  strings.Trim(s, "ox")       // "123123"     -> 양쪽의 o, x 모두 제거
  ```

- [문자열 연결 최적화](./26.go)
  > 문자열 연결 시 발생할 수 있는 성능 문제와 최적화 방법을 보여주는 예제입니다. strings.Builder를 활용한 효율적인 문자열 연결 방법을 설명합니다.
  ```go
  // ❌ 비효율적인 문자열 연결
  s := ""
  for _, v := range str {
      s += string(v)  // 매번 새로운 메모리 할당
  }

  // ✅ strings.Builder 사용
  var builder strings.Builder
  for _, v := range str {
      builder.WriteString(string(v))  // 메모리 할당 최소화
  }
  s := builder.String()
  ```

---
> 💡 **참고**: 각 예제는 ❌(Bad)와 ✅(Good) 케이스를 포함하고 있습니다. 실제 코드에서 이러한 패턴들을 주의하여 사용하세요.
